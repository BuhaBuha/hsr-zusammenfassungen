% Glossar and acronyms
\newdualentry{uml}
{UML}
{Unified Modeling Language}
{
	Ist eine grafische Modellierungssprache zur Spezifikation, Konstruktion und Dokumentation von Software-Teilen.
}

\newdualentry{ssd}
{SSD}
{System Sequence Diagram}
{
	Ist ein Black-Box Systemdiagramm für Systemoperationen. Es zeigt die Interaktion von einem Actor mit einem System.
}

\newdualentry{furps}
{FURPS+}
{Functionality, Usability, Reliability, Performance/Portability, Supportability, +Others}
{
	Ist ein Akronym für die Qualitätsmerkmale (nicht funktionale Anforderungen) von Software. 
}

\newdualentry{srs}
{SRS}
{Software Requirements Specification}
{
	Methodisches Vorgehen und Ablauf, um Fähigkeiten und Bedingungen festzulegen, die die Software erfüllen muss
}

\newdualentry{up}
{UP}
{Unified Process}
{
	Verbreiteter iterativer und inkrementeller Software Enwicklungsprozess. Bekannteste Vertreter sind Rational Unified Process (RUP) und Open Unified Process
}

\newdualentry{rup}
{RUP}
{Rational unified Process}
{
	Ist eine Variante von Unified Process.
}

\newdualentry{ebp}
{EBP}
{Elementary Business Process}
{
	Eine Aufgabe die durch eine Person an einem Ort zu einem Zeitpunkt durchgeführt werden kann. Use Cases sollten alle elementaren Geschäftsprozesse abdecken.
}

\newdualentry{grasp}
{GRASP}
{General Responsibility Assignment Software Patterns}
{
	Eine Menge von Entwurfsmuster, die die Zuständigkeit einer Klasse definieren.
}

\newdualentry{erd}
{ERD}
{Entity-Relationship-Modell}
{
	Grafische Darstellung der Entitäten und deren Beziehungen untereinander.
}


\newglossaryentry{gls-kohaeson}
{
	name={Kohäsion},
	description={Zusammenhalt innerhalb einer Klasse}
}

\newglossaryentry{gls-kopplung}
{
	name={Kopplung},
	description={Wie stark ist eine Klasse abhängig von vielen anderen Klassen}
}

\newglossaryentry{gls-staticmodel}
{
	name={Statisches Modell},
	description={Zum statischen Modell gehören ERD's und Klassendiagramme}
}

\newglossaryentry{gls-dynamicmodel}
{
	name={Dynamisches Modell},
	description={Das dynamische Modell dient der Überprüfung zwischen dem statischem Modell und den Use Cases (Funktionale Anforderungen). Es beinhaltet Black und Whitebox Tests, sowie Zustands- und Activity-Diagramme}
}

\newglossaryentry{gls-functionalrequirements}
{
	name={Funktionale Anforderungen},
	description={Anforderungen an das Was? Funktionale Anforderungen werden meist mit Use Cases ausgedrückt}
}

\newglossaryentry{gls-nonfunctionalrequirements}
{
	name={Nicht Funktionale Anforderungen},
	description={Nicht funktionale Anforderungen fragen nach dem Wie? Es geht um die Leistung, Geschwindigkeit, Menge, Qualität und die verwendeten Technolgien.}
}

\newglossaryentry{gls-domainmodel}
{
	name={Domainmodell},
	description={Zeigt die Konzepte mit Eigenschaften aber ohne Methoden. Kann auch nicht persistente Objekte enthalten.}
}

\newglossaryentry{gls-datamodel}
{
	name={Datenmodell},
	description={Zeigt persistente Entitäten in der Datenbank (ERD)}
}

\newglossaryentry{gls-classmodel}
{
	name={Designmodell, Klassenmodell},
	description={Zeigt persistenten Klassen inkl. Methoden}
}

\newglossaryentry{gls-defensiveprog}
{
	name={Defensive Programming},
	description={Bei undefiniertem oder fehlerhaften Eingaben wird immer eine Exception geworfen}
}

\newglossaryentry{gls-designbycontract}
{
	name={Programming by Contract},
	description={Im Gegensatz zum Defensive Programming ist der Aufrufer dafür zuständig, dass er nur gültige Werte einer Methode übergibt.}
}

\newdualentry{gof}
{GOF}
{Gang of Four}
{
	Autoren des Buchs ''Design Patterns. Elements of Reusable Object-Oriented Software''. Geschrieben von Erich Gamma, Richard Helm, Ralph Johnson und John Vlissides. 
}

\newdualentry{solid}
{SOLID}
{Single Responsibility, Open-closed, Liskov substitution, Interface segregation, Dependency inversion}
{
	Fünf Grundlegende Prinzipien für die Objektorientierte Enwicklung und Design.
}

\newdualentry{dry}
{DRY}
{Don't Repeat Yourself}
{
	Kein duplizierter Code
}

\newdualentry{die}
{DIE}
{Duplicate is Evil}
{
	Kein duplizierter Code
}

\newdualentry{kiss}
{KISS}
{Keep It Simple Stupid}
{
	Es ist schwerer, den Programmcode einfach zu halten, anstatt ihn komplex zu programmieren.
}

\newdualentry{yagni}
{YAGNI}
{You Ain't Gonna Need it}
{
	Keine Implementierung im Sinne ''In der Zukunft könnte man das brauchen''
}

